# Picker

*See: packages/react-native-baseline-inputs/src/index.ts*

## Props

| Name | Type | Description |
|------|------|-------------|
| <strong>items</strong> <sup><em>required</em></sup> | `PickerItem[]` |  |
| <strong>value</strong> <sup><em>required</em></sup> | `any` |  |
| <strong>accessibilityActions</strong> | `string[]` | Provides an array of custom actions available for accessibility.&lt;br&gt;@platform ios |
| <strong>accessibilityComponentType</strong> | `&quot;none&quot; \| &quot;button&quot; \| &quot;radiobutton_checked&quot; \| &quot;radiobutton_unchecked&quot;` | In some cases, we also want to alert the end user of the type of selected component (i.e., that it is a “button”).&lt;br&gt;If we were using native buttons, this would work automatically. Since we are using javascript, we need to&lt;br&gt;provide a bit more context for TalkBack. To do so, you must specify the ‘accessibilityComponentType’ property&lt;br&gt;for any UI component. For instances, we support ‘button’, ‘radiobutton_checked’ and ‘radiobutton_unchecked’ and so on.&lt;br&gt;@platform android |
| <strong>accessibilityElementsHidden</strong> | `boolean` | A Boolean value indicating whether the accessibility elements contained within this accessibility element&lt;br&gt;are hidden to the screen reader.&lt;br&gt;@platform ios |
| <strong>accessibilityHint</strong> | `string` | An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not obvious from the accessibility label. |
| <strong>accessibilityIgnoresInvertColors</strong> | `boolean` | https://facebook.github.io/react-native/docs/accessibility#accessibilityignoresinvertcolorsios&lt;br&gt;@platform ios |
| <strong>accessibilityLabel</strong> | `string` | Overrides the text that&#x27;s read by the screen reader when the user interacts with the element. By default, the&lt;br&gt;label is constructed by traversing all the children and accumulating all the Text nodes separated by space. |
| <strong>accessibilityLiveRegion</strong> | `&quot;none&quot; \| &quot;polite&quot; \| &quot;assertive&quot;` | Indicates to accessibility services whether the user should be notified when this view changes.&lt;br&gt;Works for Android API &gt;&#x3D; 19 only.&lt;br&gt;See http://developer.android.com/reference/android/view/View.html#attr_android:accessibilityLiveRegion for references.&lt;br&gt;@platform android |
| <strong>accessibilityRole</strong> | `AccessibilityRole` | Accessibility Role tells a person using either VoiceOver on iOS or TalkBack on Android the type of element that is focused on. |
| <strong>accessibilityStates</strong> | `AccessibilityState[]` | Accessibility State tells a person using either VoiceOver on iOS or TalkBack on Android the state of the element currently focused on. |
| <strong>accessibilityTraits</strong> | `&quot;none&quot; \| &quot;search&quot; \| &quot;button&quot; \| &quot;link&quot; \| &quot;image&quot; \| &quot;text&quot; \| &quot;adjustable&quot; \| &quot;header&quot; \| &quot;summary&quot; \| &quot;selected&quot; \| &quot;disabled&quot; \| &quot;plays&quot; \| &quot;key&quot; \| &quot;frequentUpdates&quot; \| &quot;startsMedia&quot; \| &quot;allowsDirectInteraction&quot; \| &quot;pageTurn&quot; \| AccessibilityTrait[]` | Accessibility traits tell a person using VoiceOver what kind of element they have selected.&lt;br&gt;Is this element a label? A button? A header? These questions are answered by accessibilityTraits.&lt;br&gt;@platform ios |
| <strong>accessibilityViewIsModal</strong> | `boolean` | A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.&lt;br&gt;@platform ios |
| <strong>accessible</strong> | `boolean` | When true, indicates that the view is an accessibility element.&lt;br&gt;By default, all the touchable elements are accessible. |
| <strong>collapsable</strong> | `boolean` | Views that are only used to layout their children or otherwise don&#x27;t draw anything&lt;br&gt;may be automatically removed from the native hierarchy as an optimization.&lt;br&gt;Set this property to false to disable this optimization and ensure that this View exists in the native view hierarchy. |
| <strong>enabled</strong> | `boolean` | If set to false, the picker will be disabled, i.e. the user will not be able to make a&lt;br&gt;selection.&lt;br&gt;@platform android |
| <strong>hasTVPreferredFocus</strong> | `boolean` | *(Apple TV only)* May be set to true to force the Apple TV focus engine to move focus to this view.&lt;br&gt;@platform ios |
| <strong>hitSlop</strong> | `Insets` | This defines how far a touch event can start away from the view.&lt;br&gt;Typical interface guidelines recommend touch targets that are at least&lt;br&gt;30 - 40 points/density-independent pixels. If a Touchable view has&lt;br&gt;a height of 20 the touchable height can be extended to 40 with&lt;br&gt;hitSlop&#x3D;{{top: 10, bottom: 10, left: 0, right: 0}}&lt;br&gt;NOTE The touch area never extends past the parent view bounds and&lt;br&gt;the Z-index of sibling views always takes precedence if a touch&lt;br&gt;hits two overlapping views. |
| <strong>importantForAccessibility</strong> | `&quot;auto&quot; \| &quot;yes&quot; \| &quot;no&quot; \| &quot;no-hide-descendants&quot;` | Controls how view is important for accessibility which is if it fires accessibility events&lt;br&gt;and if it is reported to accessibility services that query the screen.&lt;br&gt;Works for Android only. See http://developer.android.com/reference/android/R.attr.html#importantForAccessibility for references.&lt;br&gt;&lt;br&gt;Possible values:&lt;br&gt;      &#x27;auto&#x27; - The system determines whether the view is important for accessibility - default (recommended).&lt;br&gt;      &#x27;yes&#x27; - The view is important for accessibility.&lt;br&gt;      &#x27;no&#x27; - The view is not important for accessibility.&lt;br&gt;      &#x27;no-hide-descendants&#x27; - The view is not important for accessibility, nor are any of its descendant views. |
| <strong>inputProps</strong> | `Partial&lt;StaticInputProps&gt;` |  |
| <strong>isTVSelectable</strong> | `boolean` | *(Apple TV only)* When set to true, this view will be focusable&lt;br&gt;and navigable using the Apple TV remote.&lt;br&gt;@platform ios |
| <strong>itemStyle</strong> | `StyleProp&lt;TextStyle&gt;` | Style to apply to each of the item labels.&lt;br&gt;@platform ios |
| <strong>modalProps</strong> | `Partial&lt;ModalProps&gt;` |  |
| <strong>modalStyle</strong> | `StyleProp&lt;ViewStyle&gt;` |  |
| <strong>mode</strong> | `&quot;dialog&quot; \| &quot;dropdown&quot;` | On Android, specifies how to display the selection items when the user taps on the picker:&lt;br&gt;&lt;br&gt;   - &#x27;dialog&#x27;: Show a modal dialog. This is the default.&lt;br&gt;   - &#x27;dropdown&#x27;: Shows a dropdown anchored to the picker view&lt;br&gt;@platform android |
| <strong>nativeID</strong> | `string` | Used to reference react managed views from native code. |
| <strong>needsOffscreenAlphaCompositing</strong> | `boolean` | Whether this view needs to rendered offscreen and composited with an alpha in order to preserve 100% correct colors and blending behavior.&lt;br&gt;The default (false) falls back to drawing the component and its children&lt;br&gt;with an alpha applied to the paint used to draw each element instead of rendering the full component offscreen and compositing it back with an alpha value.&lt;br&gt;This default may be noticeable and undesired in the case where the View you are setting an opacity on&lt;br&gt;has multiple overlapping elements (e.g. multiple overlapping Views, or text and a background).&lt;br&gt;&lt;br&gt;Rendering offscreen to preserve correct alpha behavior is extremely expensive&lt;br&gt;and hard to debug for non-native developers, which is why it is not turned on by default.&lt;br&gt;If you do need to enable this property for an animation,&lt;br&gt;consider combining it with renderToHardwareTextureAndroid if the view contents are static (i.e. it doesn&#x27;t need to be redrawn each frame).&lt;br&gt;If that property is enabled, this View will be rendered off-screen once,&lt;br&gt;saved in a hardware texture, and then composited onto the screen with an alpha each frame without having to switch rendering targets on the GPU. |
| <strong>onAccessibilityAction</strong> | `() &#x3D;&gt; void` | When &#x60;accessible&#x60; is true, the system will try to invoke this function&lt;br&gt;when the user performs an accessibility custom action.&lt;br&gt;@platform ios |
| <strong>onAccessibilityTap</strong> | `() &#x3D;&gt; void` | When &#x60;accessible&#x60; is true, the system will try to invoke this function when the user performs accessibility tap gesture.&lt;br&gt;@platform ios |
| <strong>onChange</strong> | `(value: any) &#x3D;&gt; void` |  |
| <strong>onLayout</strong> | `(event: LayoutChangeEvent) &#x3D;&gt; void` | Invoked on mount and layout changes with&lt;br&gt;&lt;br&gt;{nativeEvent: { layout: {x, y, width, height}}}. |
| <strong>onMagicTap</strong> | `() &#x3D;&gt; void` | When accessible is true, the system will invoke this function when the user performs the magic tap gesture.&lt;br&gt;@platform ios |
| <strong>onModalClose</strong> | `() &#x3D;&gt; void` |  |
| <strong>onModalOpen</strong> | `() &#x3D;&gt; void` |  |
| <strong>onMoveShouldSetResponder</strong> | `(event: GestureResponderEvent) &#x3D;&gt; boolean` | Called for every touch move on the View when it is not the responder: does this view want to &quot;claim&quot; touch responsiveness? |
| <strong>onMoveShouldSetResponderCapture</strong> | `(event: GestureResponderEvent) &#x3D;&gt; boolean` | onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,&lt;br&gt;where the deepest node is called first.&lt;br&gt;That means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.&lt;br&gt;This is desirable in most cases, because it makes sure all controls and buttons are usable.&lt;br&gt;&lt;br&gt;However, sometimes a parent will want to make sure that it becomes responder.&lt;br&gt;This can be handled by using the capture phase.&lt;br&gt;Before the responder system bubbles up from the deepest component,&lt;br&gt;it will do a capture phase, firing on*ShouldSetResponderCapture.&lt;br&gt;So if a parent View wants to prevent the child from becoming responder on a touch start,&lt;br&gt;it should have a onStartShouldSetResponderCapture handler which returns true. |
| <strong>onResponderEnd</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | If the View returns true and attempts to become the responder, one of the following will happen: |
| <strong>onResponderGrant</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | The View is now responding for touch events.&lt;br&gt;This is the time to highlight and show the user what is happening |
| <strong>onResponderMove</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | If the view is responding, the following handlers can be called:&lt;br&gt;The user is moving their finger |
| <strong>onResponderReject</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | Something else is the responder right now and will not release it |
| <strong>onResponderRelease</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | Fired at the end of the touch, ie &quot;touchUp&quot; |
| <strong>onResponderStart</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>onResponderTerminate</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` | The responder has been taken from the View.&lt;br&gt;Might be taken by other views after a call to onResponderTerminationRequest,&lt;br&gt;or might be taken by the OS without asking (happens with control center/ notification center on iOS) |
| <strong>onResponderTerminationRequest</strong> | `(event: GestureResponderEvent) &#x3D;&gt; boolean` | Something else wants to become responder.&lt;br&gt;Should this view release the responder? Returning true allows release |
| <strong>onStartShouldSetResponder</strong> | `(event: GestureResponderEvent) &#x3D;&gt; boolean` | A view can become the touch responder by implementing the correct negotiation methods.&lt;br&gt;There are two methods to ask the view if it wants to become responder:&lt;br&gt;Does this view want to become responder on the start of a touch? |
| <strong>onStartShouldSetResponderCapture</strong> | `(event: GestureResponderEvent) &#x3D;&gt; boolean` | onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,&lt;br&gt;where the deepest node is called first.&lt;br&gt;That means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.&lt;br&gt;This is desirable in most cases, because it makes sure all controls and buttons are usable.&lt;br&gt;&lt;br&gt;However, sometimes a parent will want to make sure that it becomes responder.&lt;br&gt;This can be handled by using the capture phase.&lt;br&gt;Before the responder system bubbles up from the deepest component,&lt;br&gt;it will do a capture phase, firing on*ShouldSetResponderCapture.&lt;br&gt;So if a parent View wants to prevent the child from becoming responder on a touch start,&lt;br&gt;it should have a onStartShouldSetResponderCapture handler which returns true. |
| <strong>onTouchCancel</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>onTouchEnd</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>onTouchEndCapture</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>onTouchMove</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>onTouchStart</strong> | `(event: GestureResponderEvent) &#x3D;&gt; void` |  |
| <strong>pickerStyle</strong> | `StyleProp&lt;ViewStyle&gt;` |  |
| <strong>pointerEvents</strong> | `&quot;none&quot; \| &quot;box-none&quot; \| &quot;box-only&quot; \| &quot;auto&quot;` | In the absence of auto property, none is much like CSS&#x27;s none value. box-none is as if you had applied the CSS class:&lt;br&gt;&lt;br&gt;.box-none {&lt;br&gt;   pointer-events: none;&lt;br&gt;}&lt;br&gt;.box-none * {&lt;br&gt;   pointer-events: all;&lt;br&gt;}&lt;br&gt;&lt;br&gt;box-only is the equivalent of&lt;br&gt;&lt;br&gt;.box-only {&lt;br&gt;   pointer-events: all;&lt;br&gt;}&lt;br&gt;.box-only * {&lt;br&gt;   pointer-events: none;&lt;br&gt;}&lt;br&gt;&lt;br&gt;But since pointerEvents does not affect layout/appearance, and we are already deviating from the spec by adding additional modes,&lt;br&gt;we opt to not include pointerEvents on style. On some platforms, we would need to implement it as a className anyways. Using style or not is an implementation detail of the platform. |
| <strong>prompt</strong> | `string` | Prompt string for this picker, used on Android in dialog mode as the title of the dialog.&lt;br&gt;@platform android |
| <strong>removeClippedSubviews</strong> | `boolean` | This is a special performance property exposed by RCTView and is useful for scrolling content when there are many subviews,&lt;br&gt;most of which are offscreen. For this property to be effective, it must be applied to a view that contains many subviews that extend outside its bound.&lt;br&gt;The subviews must also have overflow: hidden, as should the containing view (or one of its superviews). |
| <strong>renderToHardwareTextureAndroid</strong> | `boolean` | Whether this view should render itself (and all of its children) into a single hardware texture on the GPU.&lt;br&gt;&lt;br&gt;On Android, this is useful for animations and interactions that only modify opacity, rotation, translation, and/or scale:&lt;br&gt;in those cases, the view doesn&#x27;t have to be redrawn and display lists don&#x27;t need to be re-executed. The texture can just be&lt;br&gt;re-used and re-composited with different parameters. The downside is that this can use up limited video memory, so this prop should be set back to false at the end of the interaction/animation. |
| <strong>selectedValue</strong> | `any` | Value matching value of one of the items.&lt;br&gt;Can be a string or an integer. |
| <strong>shouldRasterizeIOS</strong> | `boolean` | Whether this view should be rendered as a bitmap before compositing.&lt;br&gt;&lt;br&gt;On iOS, this is useful for animations and interactions that do not modify this component&#x27;s dimensions nor its children;&lt;br&gt;for example, when translating the position of a static view, rasterization allows the renderer to reuse a cached bitmap of a static view&lt;br&gt;and quickly composite it during each frame.&lt;br&gt;&lt;br&gt;Rasterization incurs an off-screen drawing pass and the bitmap consumes memory.&lt;br&gt;Test and measure when using this property. |
| <strong>style</strong> | `StyleProp&lt;ViewStyle&gt;` |  |
| <strong>testID</strong> | `string` | Used to locate this view in end-to-end tests. |
| <strong>testId</strong> | `string` | Used to locate this view in end-to-end tests. |
| <strong>tvParallaxMagnification</strong> | `number` | *(Apple TV only)* May be used to change the appearance of the Apple TV parallax effect when this view goes in or out of focus.  Defaults to 1.0.&lt;br&gt;@platform ios |
| <strong>tvParallaxProperties</strong> | `TVParallaxProperties` | *(Apple TV only)* Object with properties to control Apple TV parallax effects.&lt;br&gt;@platform ios |
| <strong>tvParallaxShiftDistanceX</strong> | `number` | *(Apple TV only)* May be used to change the appearance of the Apple TV parallax effect when this view goes in or out of focus.  Defaults to 2.0.&lt;br&gt;@platform ios |
| <strong>tvParallaxShiftDistanceY</strong> | `number` | *(Apple TV only)* May be used to change the appearance of the Apple TV parallax effect when this view goes in or out of focus.  Defaults to 2.0.&lt;br&gt;@platform ios |
| <strong>tvParallaxTiltAngle</strong> | `number` | *(Apple TV only)* May be used to change the appearance of the Apple TV parallax effect when this view goes in or out of focus.  Defaults to 0.05.&lt;br&gt;@platform ios |
